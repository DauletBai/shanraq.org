// parser.tng - Tenge парсер (синтакс талдау)
// Агглютинативтік парсер

atqar parser_jasau() -> Parser {
    jasau parser: Parser = parser_create();
    qaytar parser;
}

// Кодды парслау
atqar parser_parse(parser: Parser, tokens: Token[]) -> AST {
    jasau ast: AST = ast_create();
    jasau position: san = 0;
    
    azirshe (position < tokens.length) {
        jasau node: ASTNode = parser_parse_statement(parser, tokens, position);
        eгер (node != NULL) {
            ast_add_node(ast, node);
            position = node.end_position;
        } aitpese {
            position = position + 1;
        }
    }
    
    qaytar ast;
}

// Statement парслау
atqar parser_parse_statement(parser: Parser, tokens: Token[], position: san) -> ASTNode {
    jasau token: Token = tokens[position];
    
    eгер (token.type == "KEYWORD" && token.value == "atqar") {
        qaytar parser_parse_function_declaration(parser, tokens, position);
    } aitpese eгер (token.type == "KEYWORD" && token.value == "jasau") {
        qaytar parser_parse_variable_declaration(parser, tokens, position);
    } aitpese eгер (token.type == "KEYWORD" && token.value == "eger") {
        qaytar parser_parse_if_statement(parser, tokens, position);
    } aitpese eгер (token.type == "KEYWORD" && token.value == "azirshe") {
        qaytar parser_parse_while_loop(parser, tokens, position);
    } aitpese eгер (token.type == "KEYWORD" && token.value == "korset") {
        qaytar parser_parse_print_statement(parser, tokens, position);
    } aitpese eгер (token.type == "KEYWORD" && token.value == "qaytar") {
        qaytar parser_parse_return_statement(parser, tokens, position);
    } aitpese {
        qaytar parser_parse_expression(parser, tokens, position);
    }
}

// Функция декларациясын парслау
atqar parser_parse_function_declaration(parser: Parser, tokens: Token[], position: san) -> ASTNode {
    jasau node: ASTNode = ast_node_create("FUNCTION_DECLARATION");
    jasau current_position: san = position + 1;
    
    // Функция атын алу
    eгер (current_position < tokens.length && tokens[current_position].type == "IDENTIFIER") {
        jasau function_name: jol = tokens[current_position].value;
        ast_node_set_string(node, "name", function_name);
        current_position = current_position + 1;
    }
    
    // Параметрлерді алу
    eгер (current_position < tokens.length && tokens[current_position].value == "(") {
        jasau parameters: ASTNode[] = parser_parse_parameters(parser, tokens, current_position);
        ast_node_set_array(node, "parameters", parameters);
        current_position = current_position + 1;
    }
    
    // Return типін алу
    eгер (current_position < tokens.length && tokens[current_position].value == "->") {
        current_position = current_position + 1;
        eгер (current_position < tokens.length && tokens[current_position].type == "IDENTIFIER") {
            jasau return_type: jol = tokens[current_position].value;
            ast_node_set_string(node, "return_type", return_type);
            current_position = current_position + 1;
        }
    }
    
    // Функция денесін алу
    eгер (current_position < tokens.length && tokens[current_position].value == "{") {
        jasau body: ASTNode[] = parser_parse_block(parser, tokens, current_position);
        ast_node_set_array(node, "body", body);
        current_position = current_position + 1;
    }
    
    node.end_position = current_position;
    qaytar node;
}

// Параметрлерді парслау
atqar parser_parse_parameters(parser: Parser, tokens: Token[], position: san) -> ASTNode[] {
    jasau parameters: ASTNode[] = [];
    jasau current_position: san = position + 1; // ( символын өткізу
    
    azirshe (current_position < tokens.length && tokens[current_position].value != ")") {
        eгер (tokens[current_position].type == "IDENTIFIER") {
            jasau param: ASTNode = ast_node_create("PARAMETER");
            jasau param_name: jol = tokens[current_position].value;
            ast_node_set_string(param, "name", param_name);
            current_position = current_position + 1;
            
            // Типті алу
            eгер (current_position < tokens.length && tokens[current_position].value == ":") {
                current_position = current_position + 1;
                eгер (current_position < tokens.length && tokens[current_position].type == "IDENTIFIER") {
                    jasau param_type: jol = tokens[current_position].value;
                    ast_node_set_string(param, "type", param_type);
                    current_position = current_position + 1;
                }
            }
            
            parameters = parameters + [param];
            
            // Келесі параметрге өту
            eгер (current_position < tokens.length && tokens[current_position].value == ",") {
                current_position = current_position + 1;
            }
        } aitpese {
            current_position = current_position + 1;
        }
    }
    
    qaytar parameters;
}

// Блок парслау
atqar parser_parse_block(parser: Parser, tokens: Token[], position: san) -> ASTNode[] {
    jasau statements: ASTNode[] = [];
    jasau current_position: san = position + 1; // { символын өткізу
    jasau brace_count: san = 1;
    
    azirshe (current_position < tokens.length && brace_count > 0) {
        eгер (tokens[current_position].value == "{") {
            brace_count = brace_count + 1;
        } aitpese eгер (tokens[current_position].value == "}") {
            brace_count = brace_count - 1;
        }
        
        eгер (brace_count > 0) {
            jasau statement: ASTNode = parser_parse_statement(parser, tokens, current_position);
            eгер (statement != NULL) {
                statements = statements + [statement];
                current_position = statement.end_position;
            } aitpese {
                current_position = current_position + 1;
            }
        }
    }
    
    qaytar statements;
}

// Айнымалы декларациясын парслау
atqar parser_parse_variable_declaration(parser: Parser, tokens: Token[], position: san) -> ASTNode {
    jasau node: ASTNode = ast_node_create("VARIABLE_DECLARATION");
    jasau current_position: san = position + 1;
    
    // Айнымалы атын алу
    eгер (current_position < tokens.length && tokens[current_position].type == "IDENTIFIER") {
        jasau variable_name: jol = tokens[current_position].value;
        ast_node_set_string(node, "name", variable_name);
        current_position = current_position + 1;
    }
    
    // Типті алу
    eгер (current_position < tokens.length && tokens[current_position].value == ":") {
        current_position = current_position + 1;
        eгер (current_position < tokens.length && tokens[current_position].type == "IDENTIFIER") {
            jasau variable_type: jol = tokens[current_position].value;
            ast_node_set_string(node, "type", variable_type);
            current_position = current_position + 1;
        }
    }
    
    // Мәнді алу
    eгер (current_position < tokens.length && tokens[current_position].value == "=") {
        current_position = current_position + 1;
        jasau value: ASTNode = parser_parse_expression(parser, tokens, current_position);
        ast_node_set_node(node, "value", value);
        current_position = value.end_position;
    }
    
    node.end_position = current_position;
    qaytar node;
}

// If statement парслау
atqar parser_parse_if_statement(parser: Parser, tokens: Token[], position: san) -> ASTNode {
    jasau node: ASTNode = ast_node_create("IF_STATEMENT");
    jasau current_position: san = position + 1;
    
    // Шартты алу
    jasau condition: ASTNode = parser_parse_expression(parser, tokens, current_position);
    ast_node_set_node(node, "condition", condition);
    current_position = condition.end_position;
    
    // If блокын алу
    eгер (current_position < tokens.length && tokens[current_position].value == "{") {
        jasau if_body: ASTNode[] = parser_parse_block(parser, tokens, current_position);
        ast_node_set_array(node, "if_body", if_body);
        current_position = current_position + 1;
    }
    
    // Else блокын алу
    eгер (current_position < tokens.length && tokens[current_position].type == "KEYWORD" && tokens[current_position].value == "aitpese") {
        current_position = current_position + 1;
        eгер (current_position < tokens.length && tokens[current_position].value == "{") {
            jasau else_body: ASTNode[] = parser_parse_block(parser, tokens, current_position);
            ast_node_set_array(node, "else_body", else_body);
            current_position = current_position + 1;
        }
    }
    
    node.end_position = current_position;
    qaytar node;
}

// While loop парслау
atqar parser_parse_while_loop(parser: Parser, tokens: Token[], position: san) -> ASTNode {
    jasau node: ASTNode = ast_node_create("WHILE_LOOP");
    jasau current_position: san = position + 1;
    
    // Шартты алу
    jasau condition: ASTNode = parser_parse_expression(parser, tokens, current_position);
    ast_node_set_node(node, "condition", condition);
    current_position = condition.end_position;
    
    // While блокын алу
    eгер (current_position < tokens.length && tokens[current_position].value == "{") {
        jasau body: ASTNode[] = parser_parse_block(parser, tokens, current_position);
        ast_node_set_array(node, "body", body);
        current_position = current_position + 1;
    }
    
    node.end_position = current_position;
    qaytar node;
}

// Print statement парслау
atqar parser_parse_print_statement(parser: Parser, tokens: Token[], position: san) -> ASTNode {
    jasau node: ASTNode = ast_node_create("PRINT_STATEMENT");
    jasau current_position: san = position + 1;
    
    // Print мәнін алу
    eгер (current_position < tokens.length && tokens[current_position].value == "(") {
        current_position = current_position + 1;
        jasau value: ASTNode = parser_parse_expression(parser, tokens, current_position);
        ast_node_set_node(node, "value", value);
        current_position = value.end_position;
        
        eгер (current_position < tokens.length && tokens[current_position].value == ")") {
            current_position = current_position + 1;
        }
    }
    
    node.end_position = current_position;
    qaytar node;
}

// Return statement парслау
atqar parser_parse_return_statement(parser: Parser, tokens: Token[], position: san) -> ASTNode {
    jasau node: ASTNode = ast_node_create("RETURN_STATEMENT");
    jasau current_position: san = position + 1;
    
    // Return мәнін алу
    eгер (current_position < tokens.length && tokens[current_position].value != ";") {
        jasau value: ASTNode = parser_parse_expression(parser, tokens, current_position);
        ast_node_set_node(node, "value", value);
        current_position = value.end_position;
    }
    
    node.end_position = current_position;
    qaytar node;
}

// Expression парслау
atqar parser_parse_expression(parser: Parser, tokens: Token[], position: san) -> ASTNode {
    qaytar parser_parse_assignment_expression(parser, tokens, position);
}

// Assignment expression парслау
atqar parser_parse_assignment_expression(parser: Parser, tokens: Token[], position: san) -> ASTNode {
    jasau left: ASTNode = parser_parse_logical_or_expression(parser, tokens, position);
    jasau current_position: san = left.end_position;
    
    eгер (current_position < tokens.length && tokens[current_position].value == "=") {
        jasau node: ASTNode = ast_node_create("ASSIGNMENT");
        ast_node_set_node(node, "left", left);
        current_position = current_position + 1;
        jasau right: ASTNode = parser_parse_assignment_expression(parser, tokens, current_position);
        ast_node_set_node(node, "right", right);
        node.end_position = right.end_position;
        qaytar node;
    }
    
    qaytar left;
}

// Logical OR expression парслау
atqar parser_parse_logical_or_expression(parser: Parser, tokens: Token[], position: san) -> ASTNode {
    jasau left: ASTNode = parser_parse_logical_and_expression(parser, tokens, position);
    jasau current_position: san = left.end_position;
    
    azirshe (current_position < tokens.length && tokens[current_position].value == "||") {
        jasau node: ASTNode = ast_node_create("LOGICAL_OR");
        ast_node_set_node(node, "left", left);
        current_position = current_position + 1;
        jasau right: ASTNode = parser_parse_logical_and_expression(parser, tokens, current_position);
        ast_node_set_node(node, "right", right);
        left = node;
        current_position = right.end_position;
    }
    
    left.end_position = current_position;
    qaytar left;
}

// Logical AND expression парслау
atqar parser_parse_logical_and_expression(parser: Parser, tokens: Token[], position: san) -> ASTNode {
    jasau left: ASTNode = parser_parse_equality_expression(parser, tokens, position);
    jasau current_position: san = left.end_position;
    
    azirshe (current_position < tokens.length && tokens[current_position].value == "&&") {
        jasau node: ASTNode = ast_node_create("LOGICAL_AND");
        ast_node_set_node(node, "left", left);
        current_position = current_position + 1;
        jasau right: ASTNode = parser_parse_equality_expression(parser, tokens, current_position);
        ast_node_set_node(node, "right", right);
        left = node;
        current_position = right.end_position;
    }
    
    left.end_position = current_position;
    qaytar left;
}

// Equality expression парслау
atqar parser_parse_equality_expression(parser: Parser, tokens: Token[], position: san) -> ASTNode {
    jasau left: ASTNode = parser_parse_relational_expression(parser, tokens, position);
    jasau current_position: san = left.end_position;
    
    azirshe (current_position < tokens.length && (tokens[current_position].value == "==" || tokens[current_position].value == "!=")) {
        jasau node: ASTNode = ast_node_create("EQUALITY");
        ast_node_set_string(node, "operator", tokens[current_position].value);
        ast_node_set_node(node, "left", left);
        current_position = current_position + 1;
        jasau right: ASTNode = parser_parse_relational_expression(parser, tokens, current_position);
        ast_node_set_node(node, "right", right);
        left = node;
        current_position = right.end_position;
    }
    
    left.end_position = current_position;
    qaytar left;
}

// Relational expression парслау
atqar parser_parse_relational_expression(parser: Parser, tokens: Token[], position: san) -> ASTNode {
    jasau left: ASTNode = parser_parse_additive_expression(parser, tokens, position);
    jasau current_position: san = left.end_position;
    
    azirshe (current_position < tokens.length && (tokens[current_position].value == "<" || tokens[current_position].value == ">" || 
             tokens[current_position].value == "<=" || tokens[current_position].value == ">=")) {
        jasau node: ASTNode = ast_node_create("RELATIONAL");
        ast_node_set_string(node, "operator", tokens[current_position].value);
        ast_node_set_node(node, "left", left);
        current_position = current_position + 1;
        jasau right: ASTNode = parser_parse_additive_expression(parser, tokens, current_position);
        ast_node_set_node(node, "right", right);
        left = node;
        current_position = right.end_position;
    }
    
    left.end_position = current_position;
    qaytar left;
}

// Additive expression парслау
atqar parser_parse_additive_expression(parser: Parser, tokens: Token[], position: san) -> ASTNode {
    jasau left: ASTNode = parser_parse_multiplicative_expression(parser, tokens, position);
    jasau current_position: san = left.end_position;
    
    azirshe (current_position < tokens.length && (tokens[current_position].value == "+" || tokens[current_position].value == "-")) {
        jasau node: ASTNode = ast_node_create("ADDITIVE");
        ast_node_set_string(node, "operator", tokens[current_position].value);
        ast_node_set_node(node, "left", left);
        current_position = current_position + 1;
        jasau right: ASTNode = parser_parse_multiplicative_expression(parser, tokens, current_position);
        ast_node_set_node(node, "right", right);
        left = node;
        current_position = right.end_position;
    }
    
    left.end_position = current_position;
    qaytar left;
}

// Multiplicative expression парслау
atqar parser_parse_multiplicative_expression(parser: Parser, tokens: Token[], position: san) -> ASTNode {
    jasau left: ASTNode = parser_parse_unary_expression(parser, tokens, position);
    jasau current_position: san = left.end_position;
    
    azirshe (current_position < tokens.length && (tokens[current_position].value == "*" || tokens[current_position].value == "/" || 
             tokens[current_position].value == "%")) {
        jasau node: ASTNode = ast_node_create("MULTIPLICATIVE");
        ast_node_set_string(node, "operator", tokens[current_position].value);
        ast_node_set_node(node, "left", left);
        current_position = current_position + 1;
        jasau right: ASTNode = parser_parse_unary_expression(parser, tokens, current_position);
        ast_node_set_node(node, "right", right);
        left = node;
        current_position = right.end_position;
    }
    
    left.end_position = current_position;
    qaytar left;
}

// Unary expression парслау
atqar parser_parse_unary_expression(parser: Parser, tokens: Token[], position: san) -> ASTNode {
    jasau current_position: san = position;
    
    eгер (current_position < tokens.length && (tokens[current_position].value == "+" || tokens[current_position].value == "-" || 
          tokens[current_position].value == "!" || tokens[current_position].value == "~")) {
        jasau node: ASTNode = ast_node_create("UNARY");
        ast_node_set_string(node, "operator", tokens[current_position].value);
        current_position = current_position + 1;
        jasau operand: ASTNode = parser_parse_unary_expression(parser, tokens, current_position);
        ast_node_set_node(node, "operand", operand);
        node.end_position = operand.end_position;
        qaytar node;
    }
    
    qaytar parser_parse_primary_expression(parser, tokens, position);
}

// Primary expression парслау
atqar parser_parse_primary_expression(parser: Parser, tokens: Token[], position: san) -> ASTNode {
    jasau token: Token = tokens[position];
    
    eгер (token.type == "IDENTIFIER") {
        jasau node: ASTNode = ast_node_create("IDENTIFIER");
        ast_node_set_string(node, "name", token.value);
        node.end_position = position + 1;
        qaytar node;
    } aitpese eгер (token.type == "NUMBER") {
        jasau node: ASTNode = ast_node_create("NUMBER");
        ast_node_set_string(node, "value", token.value);
        node.end_position = position + 1;
        qaytar node;
    } aitpese eгер (token.type == "STRING") {
        jasau node: ASTNode = ast_node_create("STRING");
        ast_node_set_string(node, "value", token.value);
        node.end_position = position + 1;
        qaytar node;
    } aitpese eгер (token.type == "KEYWORD" && (token.value == "jan" || token.value == "jin")) {
        jasau node: ASTNode = ast_node_create("BOOLEAN");
        ast_node_set_string(node, "value", token.value);
        node.end_position = position + 1;
        qaytar node;
    } aitpese eгер (token.type == "KEYWORD" && token.value == "NULL") {
        jasau node: ASTNode = ast_node_create("NULL");
        node.end_position = position + 1;
        qaytar node;
    } aitpese eгер (token.value == "(") {
        jasau expression: ASTNode = parser_parse_expression(parser, tokens, position + 1);
        eгер (position + 1 < tokens.length && tokens[position + 1].value == ")") {
            expression.end_position = position + 2;
        }
        qaytar expression;
    }
    
    // Функция шақыру
    qaytar parser_parse_function_call(parser, tokens, position);
}

// Функция шақыру парслау
atqar parser_parse_function_call(parser: Parser, tokens: Token[], position: san) -> ASTNode {
    jasau node: ASTNode = ast_node_create("FUNCTION_CALL");
    jasau current_position: san = position;
    
    eгер (current_position < tokens.length && tokens[current_position].type == "IDENTIFIER") {
        jasau function_name: jol = tokens[current_position].value;
        ast_node_set_string(node, "name", function_name);
        current_position = current_position + 1;
        
        eгер (current_position < tokens.length && tokens[current_position].value == "(") {
            jasau arguments: ASTNode[] = parser_parse_arguments(parser, tokens, current_position);
            ast_node_set_array(node, "arguments", arguments);
            current_position = current_position + 1;
        }
    }
    
    node.end_position = current_position;
    qaytar node;
}

// Аргументтерді парслау
atqar parser_parse_arguments(parser: Parser, tokens: Token[], position: san) -> ASTNode[] {
    jasau arguments: ASTNode[] = [];
    jasau current_position: san = position + 1; // ( символын өткізу
    
    azirshe (current_position < tokens.length && tokens[current_position].value != ")") {
        jasau argument: ASTNode = parser_parse_expression(parser, tokens, current_position);
        arguments = arguments + [argument];
        current_position = argument.end_position;
        
        eгер (current_position < tokens.length && tokens[current_position].value == ",") {
            current_position = current_position + 1;
        }
    }
    
    qaytar arguments;
}

// Парсер жасау
atqar parser_create() -> Parser {
    jasau parser: Parser = Parser();
    qaytar parser;
}

// AST жасау
atqar ast_create() -> AST {
    jasau ast: AST = AST();
    ast.nodes = [];
    qaytar ast;
}

// AST node жасау
atqar ast_node_create(type: jol) -> ASTNode {
    jasau node: ASTNode = ASTNode();
    node.type = type;
    node.start_position = 0;
    node.end_position = 0;
    qaytar node;
}

// AST-ға node қосу
atqar ast_add_node(ast: AST, node: ASTNode) {
    ast.nodes = ast.nodes + [node];
}

// AST node-ға мән қосу
atqar ast_node_set_string(node: ASTNode, key: jol, value: jol) {
    node.string_values[key] = value;
}

atqar ast_node_set_node(node: ASTNode, key: jol, value: ASTNode) {
    node.node_values[key] = value;
}

atqar ast_node_set_array(node: ASTNode, key: jol, value: ASTNode[]) {
    node.array_values[key] = value;
}

