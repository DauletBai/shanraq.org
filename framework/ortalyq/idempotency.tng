// idempotency.tng - Idempotency Support for API Endpoints
// Ensures API calls can be safely retried without side effects

// Idempotency key structure
atqar idempotency_key_jasau(key: jol, user_id: jol, endpoint: jol) -> IdempotencyKey {
    jasau idempotency_key: IdempotencyKey = idempotency_key_create();
    
    idempotency_key.key = key;
    idempotency_key.user_id = user_id;
    idempotency_key.endpoint = endpoint;
    idempotency_key.created_at = current_timestamp();
    idempotency_key.expires_at = current_timestamp() + 86400; // 24 hours
    idempotency_key.status = "pending";
    
    qaytar idempotency_key;
}

// Idempotency middleware
atqar idempotency_ortalyq_jasau() -> Middleware {
    jasau ortalyq: Middleware = ortalyq_create();
    ortalyq.name = "idempotency";
    ortalyq.execute = idempotency_ortalyq_execute;
    qaytar ortalyq;
}

atqar idempotency_ortalyq_execute(request: WebRequest, response: WebResponse) -> aqıqat {
    // Get idempotency key from header
    jasau idempotency_key: jol = web_request_get_header(request, "Idempotency-Key");
    
    eгер (idempotency_key == "") {
        // No idempotency key provided, continue processing
        qaytar jan;
    }
    
    // Get user ID
    jasau user_id: jol = web_request_get_user_id(request);
    jasau endpoint: jol = web_request_get_path(request);
    
    // Check if key already exists
    jasau existing_key: IdempotencyKey = idempotency_get_key(idempotency_key, user_id, endpoint);
    
    eгер (existing_key != NULL) {
        // Key exists, check status
        eгер (existing_key.status == "completed") {
            // Return cached response
            idempotency_return_cached_response(response, existing_key);
            qaytar jin; // Stop processing
        } eгер (existing_key.status == "processing") {
            // Request is already being processed
            web_response_set_status(response, 409);
            web_response_set_json(response, json_object_create_with_string("error", "Request already being processed"));
            qaytar jin;
        } eгер (existing_key.status == "failed") {
            // Previous request failed, allow retry
            idempotency_cleanup_key(existing_key);
        }
    }
    
    // Create new idempotency key
    jasau new_key: IdempotencyKey = idempotency_key_jasau(idempotency_key, user_id, endpoint);
    new_key.status = "processing";
    new_key.request_data = web_request_get_body(request);
    
    // Store key
    jasau stored: aqıqat = idempotency_store_key(new_key);
    
    eгер (!stored) {
        korset("❌ Failed to store idempotency key");
        qaytar jin;
    }
    
    // Set key in request context for later use
    web_request_set_idempotency_key(request, idempotency_key);
    
    qaytar jan;
}

// Idempotency key completion
atqar idempotency_complete_request(idempotency_key: jol, response_data: JsonObject, status_code: san) -> aqıqat {
    // Get key
    jasau key: IdempotencyKey = idempotency_get_key_by_key(idempotency_key);
    
    eгер (key == NULL) {
        korset("❌ Idempotency key not found: " + idempotency_key);
        qaytar jin;
    }
    
    // Update key status
    key.status = "completed";
    key.response_data = response_data;
    key.status_code = status_code;
    key.completed_at = current_timestamp();
    
    // Store updated key
    jasau stored: aqıqat = idempotency_store_key(key);
    
    eгер (!stored) {
        korset("❌ Failed to store completed idempotency key");
        qaytar jin;
    }
    
    qaytar jan;
}

// Idempotency key failure
atqar idempotency_fail_request(idempotency_key: jol, error_message: jol, error_code: san) -> aqıqat {
    // Get key
    jasau key: IdempotencyKey = idempotency_get_key_by_key(idempotency_key);
    
    eгер (key == NULL) {
        korset("❌ Idempotency key not found: " + idempotency_key);
        qaytar jin;
    }
    
    // Update key status
    key.status = "failed";
    key.error_message = error_message;
    key.error_code = error_code;
    key.failed_at = current_timestamp();
    
    // Store updated key
    jasau stored: aqıqat = idempotency_store_key(key);
    
    eгер (!stored) {
        korset("❌ Failed to store failed idempotency key");
        qaytar jin;
    }
    
    qaytar jan;
}

// Return cached response
atqar idempotency_return_cached_response(response: WebResponse, key: IdempotencyKey) {
    // Set response status
    web_response_set_status(response, key.status_code);
    
    // Set response headers
    web_response_set_header(response, "X-Idempotency-Key", key.key);
    web_response_set_header(response, "X-Idempotency-Status", "cached");
    web_response_set_header(response, "X-Idempotency-Date", key.completed_at.toString());
    
    // Set response body
    web_response_set_json(response, key.response_data);
}

// Idempotency key cleanup
atqar idempotency_cleanup_key(key: IdempotencyKey) -> aqıqat {
    // Delete key from storage
    jasau deleted: aqıqat = idempotency_delete_key(key);
    
    qaytar deleted;
}

// Idempotency key expiration cleanup
atqar idempotency_cleanup_expired_keys() -> aqıqat {
    jasau current_time: san = current_timestamp();
    jasau expired_keys: IdempotencyKey[] = idempotency_get_expired_keys(current_time);
    
    jasau i: san = 0;
    azirshe (i < expired_keys.length) {
        jasau key: IdempotencyKey = expired_keys[i];
        idempotency_cleanup_key(key);
        i = i + 1;
    }
    
    korset("✅ Cleaned up " + expired_keys.length + " expired idempotency keys");
    qaytar jan;
}

// Idempotency key validation
atqar idempotency_validate_key(key: jol) -> aqıqat {
    // Check key format (UUID recommended)
    jasau uuid_pattern: jol = "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$";
    jasau is_valid_format: aqıqat = key.matches(uuid_pattern);
    
    eгер (!is_valid_format) {
        korset("❌ Invalid idempotency key format");
        qaytar jin;
    }
    
    // Check key length
    eгер (key.length < 16 || key.length > 128) {
        korset("❌ Idempotency key length must be between 16 and 128 characters");
        qaytar jin;
    }
    
    qaytar jan;
}

// Idempotency key generation
atqar idempotency_generate_key() -> jol {
    // Generate UUID v4
    jasau key: jol = uuid_generate();
    
    qaytar key;
}

// Idempotency key for specific operations
atqar idempotency_key_for_transaction(user_id: jol, transaction_data: JsonObject) -> jol {
    // Create deterministic key based on transaction data
    jasau data_hash: jol = hash_sha256(json_stringify(transaction_data));
    jasau timestamp: jol = current_timestamp().toString();
    jasau key: jol = user_id + "_" + data_hash.substring(0, 16) + "_" + timestamp;
    
    qaytar key;
}

atqar idempotency_key_for_payment(user_id: jol, payment_data: JsonObject) -> jol {
    // Create deterministic key for payment
    jasau amount: jol = json_object_get_string(payment_data, "amount");
    jasau currency: jol = json_object_get_string(payment_data, "currency");
    jasau recipient: jol = json_object_get_string(payment_data, "recipient");
    jasau timestamp: jol = current_timestamp().toString();
    
    jasau key_data: jol = user_id + "_" + amount + "_" + currency + "_" + recipient + "_" + timestamp;
    jasau key: jol = hash_sha256(key_data).substring(0, 32);
    
    qaytar key;
}

// Idempotency for financial transactions
atqar financial_transaction_idempotency_jasau(transaction_id: jol, user_id: jol, transaction_data: JsonObject) -> aqıqat {
    // Generate idempotency key
    jasau idempotency_key: jol = idempotency_key_for_transaction(user_id, transaction_data);
    
    // Check if transaction already exists
    jasau existing_transaction: Transaction = double_entry_get_transaction_by_id(transaction_id);
    
    eгер (existing_transaction != NULL) {
        korset("❌ Transaction already exists: " + transaction_id);
        qaytar jin;
    }
    
    // Check idempotency key
    jasau existing_key: IdempotencyKey = idempotency_get_key(idempotency_key, user_id, "transaction");
    
    eгер (existing_key != NULL && existing_key.status == "completed") {
        korset("❌ Transaction already processed with same data");
        qaytar jin;
    }
    
    // Create idempotency key
    jasau key: IdempotencyKey = idempotency_key_jasau(idempotency_key, user_id, "transaction");
    key.status = "processing";
    key.request_data = transaction_data;
    
    jasau stored: aqıqat = idempotency_store_key(key);
    
    eгер (!stored) {
        korset("❌ Failed to store transaction idempotency key");
        qaytar jin;
    }
    
    qaytar jan;
}

// Idempotency for P2P transfers
atqar p2p_transfer_idempotency_jasau(transfer_id: jol, user_id: jol, transfer_data: JsonObject) -> aqıqat {
    // Generate idempotency key
    jasau idempotency_key: jol = idempotency_key_for_payment(user_id, transfer_data);
    
    // Check if transfer already exists
    jasau existing_transfer: P2PTransfer = p2p_get_transfer_by_id(transfer_id);
    
    eгер (existing_transfer != NULL) {
        korset("❌ P2P transfer already exists: " + transfer_id);
        qaytar jin;
    }
    
    // Check idempotency key
    jasau existing_key: IdempotencyKey = idempotency_get_key(idempotency_key, user_id, "p2p_transfer");
    
    eгер (existing_key != NULL && existing_key.status == "completed") {
        korset("❌ P2P transfer already processed with same data");
        qaytar jin;
    }
    
    // Create idempotency key
    jasau key: IdempotencyKey = idempotency_key_jasau(idempotency_key, user_id, "p2p_transfer");
    key.status = "processing";
    key.request_data = transfer_data;
    
    jasau stored: aqıqat = idempotency_store_key(key);
    
    eгер (!stored) {
        korset("❌ Failed to store P2P transfer idempotency key");
        qaytar jin;
    }
    
    qaytar jan;
}

// Idempotency statistics
atqar idempotency_statistics_alu() -> JsonObject {
    jasau stats: JsonObject = json_object_create();
    
    // Get statistics from storage
    jasau total_keys: san = idempotency_get_total_keys();
    jasau completed_keys: san = idempotency_get_completed_keys();
    jasau failed_keys: san = idempotency_get_failed_keys();
    jasau processing_keys: san = idempotency_get_processing_keys();
    jasau expired_keys: san = idempotency_get_expired_keys_count();
    
    json_object_set_number(stats, "total_keys", total_keys);
    json_object_set_number(stats, "completed_keys", completed_keys);
    json_object_set_number(stats, "failed_keys", failed_keys);
    json_object_set_number(stats, "processing_keys", processing_keys);
    json_object_set_number(stats, "expired_keys", expired_keys);
    
    // Calculate success rate
    jasau success_rate: san = 0;
    eгер (total_keys > 0) {
        success_rate = (completed_keys * 100) / total_keys;
    }
    
    json_object_set_number(stats, "success_rate_percent", success_rate);
    
    qaytar stats;
}

// Idempotency monitoring
atqar idempotency_monitoring_jasau() -> IdempotencyMonitor {
    jasau monitor: IdempotencyMonitor = idempotency_monitor_create();
    
    monitor.keys_created = 0;
    monitor.keys_completed = 0;
    monitor.keys_failed = 0;
    monitor.keys_expired = 0;
    monitor.cache_hits = 0;
    monitor.start_time = current_timestamp();
    
    qaytar monitor;
}

// Idempotency health check
atqar idempotency_health_check() -> JsonObject {
    jasau health: JsonObject = json_object_create();
    
    // Check storage connectivity
    jasau storage_ok: aqıqat = idempotency_storage_health_check();
    
    // Check key expiration cleanup
    jasau cleanup_ok: aqıqat = idempotency_cleanup_expired_keys();
    
    // Check statistics
    jasau stats: JsonObject = idempotency_statistics_alu();
    jasau success_rate: san = json_object_get_number(stats, "success_rate_percent");
    
    // Determine overall health
    jasau overall_health: jol = "healthy";
    
    eгер (!storage_ok) {
        overall_health = "unhealthy";
    } eгер (success_rate < 95) {
        overall_health = "degraded";
    }
    
    json_object_set_string(health, "status", overall_health);
    json_object_set_boolean(health, "storage_ok", storage_ok);
    json_object_set_boolean(health, "cleanup_ok", cleanup_ok);
    json_object_set_number(health, "success_rate", success_rate);
    json_object_set_number(health, "checked_at", current_timestamp());
    
    qaytar health;
}
