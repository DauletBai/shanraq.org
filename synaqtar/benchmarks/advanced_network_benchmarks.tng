// advanced_network_benchmarks.tng - Продвинутые сетевые бенчмарки
// Жетілдірілген желілік бенчмарктар

import "benchmark_helpers.tng";

// ==================== ПРОДВИНУТЫЕ СЕТЕВЫЕ ОПТИМИЗАЦИИ ====================

// Бенчмарк epoll/kqueue с edge-triggered и ring-буферами
atqar epoll_edge_triggered_benchmark(connections: san, duration_ms: san) -> BenchmarkResult {
    jasau start_time: san = time_now();
    
    // Инициализация epoll с edge-triggered
    jasau epoll_fd: san = epoll_create1(EPOLL_CLOEXEC);
    jasau events: Array<EpollEvent> = array_jasau(connections);
    
    // Создание ring-буферов для каждого соединения
    jasau ring_buffers: Array<RingBuffer> = array_jasau(connections);
    for (jasau i: san = 0; i < connections; i++) {
        ring_buffers[i] = ring_buffer_jasau(65536); // 64KB ring buffer
    }
    
    // Настройка TCP сокетов с оптимизациями
    jasau server_socket: san = create_optimized_server_socket();
    configure_tcp_optimizations(server_socket);
    
    // Edge-triggered epoll настройка
    jasau epoll_event: EpollEvent = epoll_event_jasau();
    epoll_event.events = EPOLLIN | EPOLLOUT | EPOLLET; // Edge-triggered
    epoll_event.data.fd = server_socket;
    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, server_socket, epoll_event);
    
    jasau active_connections: san = 0;
    jasau total_requests: san = 0;
    jasau total_bytes: san = 0;
    jasau end_time: san = start_time + duration_ms;
    
    // Основной цикл обработки
    while (time_now() < end_time) {
        jasau ready_fds: san = epoll_wait(epoll_fd, events, connections, 1);
        
        for (jasau i: san = 0; i < ready_fds; i++) {
            jasau fd: san = events[i].data.fd;
            
            eger (events[i].events & EPOLLIN) {
                // Обработка входящих данных с ring-буфером
                jasau bytes_read: san = process_incoming_data_ring_buffer(fd, ring_buffers[fd]);
                total_bytes += bytes_read;
                
                // Обработка HTTP запросов из ring-буфера
                jasau requests_processed: san = process_http_requests_ring_buffer(ring_buffers[fd]);
                total_requests += requests_processed;
            }
            
            eger (events[i].events & EPOLLOUT) {
                // Отправка данных с ring-буфером
                jasau bytes_sent: san = send_data_ring_buffer(fd, ring_buffers[fd]);
                total_bytes += bytes_sent;
            }
        }
    }
    
    jasau execution_time: san = time_now() - start_time;
    
    // Освобождение ресурсов
    close(epoll_fd);
    close(server_socket);
    for (jasau i: san = 0; i < connections; i++) {
        ring_buffer_free(ring_buffers[i]);
    }
    
    jasau result: BenchmarkResult = benchmark_result_jasau();
    result.algorithm = "Epoll Edge-Triggered + Ring Buffers";
    result.execution_time = execution_time;
    result.operations_count = total_requests;
    result.operations_per_second = total_requests / (execution_time / 1000.0);
    result.throughput = total_bytes / (execution_time / 1000.0);
    result.memory_usage = get_memory_usage();
    result.network_efficiency = (total_requests * 100.0) / connections;
    
    qaytar result;
}

// Бенчмарк zero-copy операций (sendfile/splice)
atqar zero_copy_operations_benchmark(file_size: san, requests: san) -> BenchmarkResult {
    jasau start_time: san = time_now();
    
    // Создание тестового файла в памяти
    jasau test_file: san = create_memory_mapped_file(file_size);
    jasau server_socket: san = create_optimized_server_socket();
    
    jasau total_bytes_sent: san = 0;
    jasau splice_operations: san = 0;
    jasau sendfile_operations: san = 0;
    
    for (jasau i: san = 0; i < requests; i++) {
        jasau client_socket: san = accept_connection(server_socket);
        
        // Zero-copy отправка с помощью sendfile
        jasau bytes_sent: san = sendfile(client_socket, test_file, 0, file_size);
        total_bytes_sent += bytes_sent;
        sendfile_operations++;
        
        // Zero-copy с помощью splice (если доступно)
        eger (splice_available()) {
            jasau splice_bytes: san = splice_file_to_socket(test_file, client_socket);
            total_bytes_sent += splice_bytes;
            splice_operations++;
        }
        
        close(client_socket);
    }
    
    jasau execution_time: san = time_now() - start_time;
    
    // Освобождение ресурсов
    close(server_socket);
    munmap_file(test_file);
    
    jasau result: BenchmarkResult = benchmark_result_jasau();
    result.algorithm = "Zero-Copy Operations (sendfile/splice)";
    result.execution_time = execution_time;
    result.operations_count = requests;
    result.operations_per_second = requests / (execution_time / 1000.0);
    result.throughput = total_bytes_sent / (execution_time / 1000.0);
    result.memory_usage = get_memory_usage();
    result.zero_copy_efficiency = (total_bytes_sent * 100.0) / (requests * file_size);
    
    qaytar result;
}

// Бенчмарк оптимизированного HTTP парсера
atqar optimized_http_parser_benchmark(requests: san, header_count: san) -> BenchmarkResult {
    jasau start_time: san = time_now();
    
    // Создание парсера с предварительно выделенными структурами
    jasau parser: HttpParser = http_parser_jasau();
    jasau header_pool: HeaderPool = header_pool_jasau(header_count * 2);
    jasau small_string_optimizer: SmallStringOptimizer = small_string_optimizer_jasau();
    
    jasau total_parsing_time: san = 0;
    jasau parsing_errors: san = 0;
    jasau memory_allocations: san = 0;
    
    for (jasau i: san = 0; i < requests; i++) {
        // Генерация HTTP запроса
        jasau http_request: jol = generate_http_request(header_count);
        
        jasau parse_start: san = time_now();
        
        // Парсинг с state-machine без аллокаций
        jasau parse_result: HttpParseResult = parse_http_request_optimized(
            parser, 
            http_request, 
            header_pool,
            small_string_optimizer
        );
        
        jasau parse_end: san = time_now();
        total_parsing_time += (parse_end - parse_start);
        
        eger (parse_result.success) {
            // Переиспользование структур
            http_parser_reset(parser);
            header_pool_reset(header_pool);
        } basqa {
            parsing_errors++;
        }
        
        memory_allocations += parse_result.allocations_count;
    }
    
    jasau execution_time: san = time_now() - start_time;
    
    // Освобождение ресурсов
    http_parser_free(parser);
    header_pool_free(header_pool);
    small_string_optimizer_free(small_string_optimizer);
    
    jasau result: BenchmarkResult = benchmark_result_jasau();
    result.algorithm = "Optimized HTTP Parser (State-Machine)";
    result.execution_time = execution_time;
    result.operations_count = requests;
    result.operations_per_second = requests / (execution_time / 1000.0);
    result.memory_usage = get_memory_usage();
    result.parsing_accuracy = ((requests - parsing_errors) * 100.0) / requests;
    result.memory_efficiency = (requests * 100.0) / memory_allocations;
    
    qaytar result;
}

// Бенчмарк TCP оптимизаций (cork/nodelay)
atqar tcp_optimizations_benchmark(connections: san, packets_per_connection: san) -> BenchmarkResult {
    jasau start_time: san = time_now();
    
    jasau server_socket: san = create_optimized_server_socket();
    configure_tcp_optimizations(server_socket);
    
    jasau total_packets_sent: san = 0;
    jasau total_bytes_sent: san = 0;
    jasau cork_operations: san = 0;
    jasau nodelay_operations: san = 0;
    
    for (jasau i: san = 0; i < connections; i++) {
        jasau client_socket: san = accept_connection(server_socket);
        
        // Настройка TCP оптимизаций для клиента
        configure_tcp_cork_nodelay(client_socket);
        
        for (jasau j: san = 0; j < packets_per_connection; j++) {
            // TCP_CORK оптимизация
            tcp_cork_enable(client_socket);
            cork_operations++;
            
            // Отправка данных
            jasau data: jol = generate_test_data(1024); // 1KB данные
            jasau bytes_sent: san = send(client_socket, data, 1024);
            total_bytes_sent += bytes_sent;
            total_packets_sent++;
            
            // TCP_NODELAY оптимизация
            tcp_nodelay_enable(client_socket);
            nodelay_operations++;
            
            // Отключение TCP_CORK для отправки
            tcp_cork_disable(client_socket);
        }
        
        close(client_socket);
    }
    
    jasau execution_time: san = time_now() - start_time;
    
    close(server_socket);
    
    jasau result: BenchmarkResult = benchmark_result_jasau();
    result.algorithm = "TCP Optimizations (Cork/Nodelay)";
    result.execution_time = execution_time;
    result.operations_count = total_packets_sent;
    result.operations_per_second = total_packets_sent / (execution_time / 1000.0);
    result.throughput = total_bytes_sent / (execution_time / 1000.0);
    result.memory_usage = get_memory_usage();
    result.tcp_efficiency = (total_packets_sent * 100.0) / (connections * packets_per_connection);
    
    qaytar result;
}

// ==================== ВСПОМОГАТЕЛЬНЫЕ СТРУКТУРЫ И ФУНКЦИИ ====================

// Ring Buffer для эффективной обработки данных
struct RingBuffer {
    buffer: Array<san>;
    head: san;
    tail: san;
    size: san;
    capacity: san;
}

atqar ring_buffer_jasau(capacity: san) -> RingBuffer {
    jasau rb: RingBuffer;
    rb.buffer = array_jasau(capacity);
    rb.head = 0;
    rb.tail = 0;
    rb.size = 0;
    rb.capacity = capacity;
    qaytar rb;
}

atqar ring_buffer_write(rb: RingBuffer, data: Array<san>, length: san) -> san {
    jasau bytes_written: san = 0;
    for (jasau i: san = 0; i < length && rb.size < rb.capacity; i++) {
        rb.buffer[rb.tail] = data[i];
        rb.tail = (rb.tail + 1) % rb.capacity;
        rb.size++;
        bytes_written++;
    }
    qaytar bytes_written;
}

atqar ring_buffer_read(rb: RingBuffer, data: Array<san>, length: san) -> san {
    jasau bytes_read: san = 0;
    for (jasau i: san = 0; i < length && rb.size > 0; i++) {
        data[i] = rb.buffer[rb.head];
        rb.head = (rb.head + 1) % rb.capacity;
        rb.size--;
        bytes_read++;
    }
    qaytar bytes_read;
}

// Epoll Event структура
struct EpollEvent {
    events: san;
    data: EpollData;
}

struct EpollData {
    fd: san;
}

atqar epoll_event_jasau() -> EpollEvent {
    jasau event: EpollEvent;
    event.events = 0;
    event.data.fd = 0;
    qaytar event;
}

// HTTP Parser с оптимизациями
struct HttpParser {
    state: san;
    method: jol;
    uri: jol;
    version: jol;
    headers: Array<HttpHeader>;
    body: jol;
}

struct HttpHeader {
    name: jol;
    value: jol;
}

struct HttpParseResult {
    success: aqıqat;
    method: jol;
    uri: jol;
    version: jol;
    headers: Array<HttpHeader>;
    body: jol;
    allocations_count: san;
}

// Header Pool для переиспользования
struct HeaderPool {
    headers: Array<HttpHeader>;
    free_indices: Array<san>;
    used_count: san;
    total_count: san;
}

atqar header_pool_jasau(size: san) -> HeaderPool {
    jasau pool: HeaderPool;
    pool.headers = array_jasau(size);
    pool.free_indices = array_jasau(size);
    pool.used_count = 0;
    pool.total_count = size;
    
    // Инициализация свободных индексов
    for (jasau i: san = 0; i < size; i++) {
        pool.free_indices[i] = i;
    }
    
    qaytar pool;
}

// Small String Optimizer
struct SmallStringOptimizer {
    small_strings: Array<jol>;
    string_pool: Array<jol>;
    pool_size: san;
}

atqar small_string_optimizer_jasau() -> SmallStringOptimizer {
    jasau optimizer: SmallStringOptimizer;
    optimizer.small_strings = array_jasau(1000);
    optimizer.string_pool = array_jol(1000);
    optimizer.pool_size = 1000;
    qaytar optimizer;
}

// ==================== СИСТЕМНЫЕ ФУНКЦИИ ====================

// Создание оптимизированного серверного сокета
atqar create_optimized_server_socket() -> san {
    jasau sockfd: san = socket(AF_INET, SOCK_STREAM, 0);
    
    // Настройка SO_REUSEADDR
    setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, 1);
    
    // Настройка TCP_NODELAY
    setsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, 1);
    
    // Настройка SO_RCVBUF и SO_SNDBUF
    setsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, 65536);
    setsockopt(sockfd, SOL_SOCKET, SO_SNDBUF, 65536);
    
    qaytar sockfd;
}

// Настройка TCP оптимизаций
atqar configure_tcp_optimizations(sockfd: san) -> void {
    // TCP_CORK для батчинга
    setsockopt(sockfd, IPPROTO_TCP, TCP_CORK, 1);
    
    // TCP_NODELAY для малых пакетов
    setsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, 1);
    
    // TCP_QUICKACK для быстрых ACK
    setsockopt(sockfd, IPPROTO_TCP, TCP_QUICKACK, 1);
}

// Настройка TCP_CORK и TCP_NODELAY
atqar configure_tcp_cork_nodelay(sockfd: san) -> void {
    setsockopt(sockfd, IPPROTO_TCP, TCP_CORK, 1);
    setsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, 1);
}

// Включение TCP_CORK
atqar tcp_cork_enable(sockfd: san) -> void {
    setsockopt(sockfd, IPPROTO_TCP, TCP_CORK, 1);
}

// Отключение TCP_CORK
atqar tcp_cork_disable(sockfd: san) -> void {
    setsockopt(sockfd, IPPROTO_TCP, TCP_CORK, 0);
}

// Включение TCP_NODELAY
atqar tcp_nodelay_enable(sockfd: san) -> void {
    setsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, 1);
}

// Обработка входящих данных с ring-буфером
atqar process_incoming_data_ring_buffer(fd: san, rb: RingBuffer) -> san {
    jasau buffer: Array<san> = array_jasau(4096);
    jasau bytes_read: san = recv(fd, buffer, 4096, MSG_DONTWAIT);
    
    eger (bytes_read > 0) {
        ring_buffer_write(rb, buffer, bytes_read);
    }
    
    qaytar bytes_read;
}

// Обработка HTTP запросов из ring-буфера
atqar process_http_requests_ring_buffer(rb: RingBuffer) -> san {
    jasau requests_processed: san = 0;
    jasau buffer: Array<san> = array_jasau(4096);
    
    while (rb.size > 0) {
        jasau bytes_read: san = ring_buffer_read(rb, buffer, 4096);
        eger (bytes_read > 0) {
            // Поиск HTTP запросов в буфере
            jasau http_requests: san = find_http_requests_in_buffer(buffer, bytes_read);
            requests_processed += http_requests;
        }
    }
    
    qaytar requests_processed;
}

// Отправка данных с ring-буфером
atqar send_data_ring_buffer(fd: san, rb: RingBuffer) -> san {
    jasau buffer: Array<san> = array_jasau(4096);
    jasau bytes_to_send: san = ring_buffer_read(rb, buffer, 4096);
    
    eger (bytes_to_send > 0) {
        jasau bytes_sent: san = send(fd, buffer, bytes_to_send, MSG_DONTWAIT);
        qaytar bytes_sent;
    }
    
    qaytar 0;
}

// Создание memory-mapped файла
atqar create_memory_mapped_file(size: san) -> san {
    jasau fd: san = open("/tmp/test_file", O_CREAT | O_RDWR, 0644);
    ftruncate(fd, size);
    jasau mapped_file: san = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    qaytar mapped_file;
}

// Zero-copy отправка файла
atqar sendfile(sockfd: san, filefd: san, offset: san, count: san) -> san {
    qaytar system_sendfile(sockfd, filefd, offset, count);
}

// Проверка доступности splice
atqar splice_available() -> aqıqat {
    qaytar system_splice_available();
}

// Zero-copy с помощью splice
atqar splice_file_to_socket(filefd: san, sockfd: san) -> san {
    qaytar system_splice(filefd, NULL, sockfd, NULL, 4096, SPLICE_F_MOVE);
}

// Оптимизированный HTTP парсер
atqar parse_http_request_optimized(
    parser: HttpParser, 
    request: jol, 
    header_pool: HeaderPool,
    optimizer: SmallStringOptimizer
) -> HttpParseResult {
    jasau result: HttpParseResult;
    result.success = false;
    result.allocations_count = 0;
    
    // State-machine парсинг без аллокаций
    jasau state: san = 0; // 0: method, 1: uri, 2: version, 3: headers, 4: body
    jasau current_pos: san = 0;
    jasau line_start: san = 0;
    
    while (current_pos < request.length) {
        jasau char: san = request[current_pos];
        
        eger (state == 0) { // Парсинг метода
            eger (char == ' ') {
                result.method = request.substring(line_start, current_pos);
                state = 1;
                line_start = current_pos + 1;
            }
        } basqa eger (state == 1) { // Парсинг URI
            eger (char == ' ') {
                result.uri = request.substring(line_start, current_pos);
                state = 2;
                line_start = current_pos + 1;
            }
        } basqa eger (state == 2) { // Парсинг версии
            eger (char == '\r' || char == '\n') {
                result.version = request.substring(line_start, current_pos);
                state = 3;
                line_start = current_pos + 2;
            }
        } basqa eger (state == 3) { // Парсинг заголовков
            eger (char == '\r' && request[current_pos + 1] == '\n') {
                eger (current_pos == line_start) {
                    state = 4; // Пустая строка - конец заголовков
                } basqa {
                    // Парсинг заголовка
                    jasau header_line: jol = request.substring(line_start, current_pos);
                    jasau colon_pos: san = header_line.indexOf(':');
                    
                    eger (colon_pos > 0) {
                        jasau header_name: jol = header_line.substring(0, colon_pos).trim();
                        jasau header_value: jol = header_line.substring(colon_pos + 1).trim();
                        
                        // Использование header pool
                        jasau header: HttpHeader = header_pool_get_header(header_pool);
                        header.name = header_name;
                        header.value = header_value;
                        result.allocations_count++;
                    }
                }
                line_start = current_pos + 2;
            }
        }
        
        current_pos++;
    }
    
    result.success = true;
    qaytar result;
}

// Получение заголовка из pool
atqar header_pool_get_header(pool: HeaderPool) -> HttpHeader {
    eger (pool.used_count < pool.total_count) {
        jasau index: san = pool.free_indices[pool.used_count];
        pool.used_count++;
        qaytar pool.headers[index];
    }
    
    // Fallback - создание нового заголовка
    jasau header: HttpHeader;
    header.name = "";
    header.value = "";
    qaytar header;
}

// Сброс header pool
atqar header_pool_reset(pool: HeaderPool) -> void {
    pool.used_count = 0;
}

// Сброс HTTP парсера
atqar http_parser_reset(parser: HttpParser) -> void {
    parser.state = 0;
    parser.method = "";
    parser.uri = "";
    parser.version = "";
    parser.headers = array_jasau(0);
    parser.body = "";
}

// Генерация HTTP запроса
atqar generate_http_request(header_count: san) -> jol {
    jasau request: jol = "GET /test HTTP/1.1\r\n";
    request += "Host: localhost\r\n";
    request += "User-Agent: Shanraq-Benchmark\r\n";
    
    for (jasau i: san = 0; i < header_count; i++) {
        request += "Header-" + int_to_string(i) + ": Value-" + int_to_string(i) + "\r\n";
    }
    
    request += "\r\n";
    qaytar request;
}

// Поиск HTTP запросов в буфере
atqar find_http_requests_in_buffer(buffer: Array<san>, length: san) -> san {
    jasau requests_found: san = 0;
    jasau pos: san = 0;
    
    while (pos < length - 3) {
        eger (buffer[pos] == '\r' && buffer[pos + 1] == '\n' && 
              buffer[pos + 2] == '\r' && buffer[pos + 3] == '\n') {
            requests_found++;
            pos += 4;
        } basqa {
            pos++;
        }
    }
    
    qaytar requests_found;
}

// Генерация тестовых данных
atqar generate_test_data(size: san) -> jol {
    jasau data: jol = "";
    for (jasau i: san = 0; i < size; i++) {
        data += "A";
    }
    qaytar data;
}

// Освобождение ресурсов
atqar ring_buffer_free(rb: RingBuffer) -> void {
    array_free(rb.buffer);
}

atqar http_parser_free(parser: HttpParser) -> void {
    array_free(parser.headers);
}

atqar header_pool_free(pool: HeaderPool) -> void {
    array_free(pool.headers);
    array_free(pool.free_indices);
}

atqar small_string_optimizer_free(optimizer: SmallStringOptimizer) -> void {
    array_free(optimizer.small_strings);
    array_free(optimizer.string_pool);
}

